# Clang Compilation Analysis JSON Format

This document describes the JSON format generated by `clang-trace-to-dashboard.js` for analyzing C++ compilation times.

## Overview

The format uses string tables and index-based lookups to minimize file size, following the same patterns as Mozilla's XPCShell timing data format. The data structure is optimized for:

- **Fast loading** in web dashboards
- **Small file size** through frequency-sorted indices
- **Rebuild impact analysis** (which files need recompiling when a header changes)
- **Timeline visualization** for individual compilation units
- **Include hierarchy navigation**

---

## Top-Level Structure

```json
{
  "metadata": { ... },
  "compilationUnits": { ... },
  "tables": { ... },
  "includes": { ... }
}
```

---

## metadata

Contains information about the data:

```json
{
  "generatedAt": "2025-12-13T12:34:56.789Z",  // ISO timestamp when file was created
  "totalCompilationUnits": 4359,              // Number of compilation units (object files)
  "totalIncludes": 1334271,                   // Total number of header inclusions
  "totalUniqueHeaders": 30258,                // Number of unique header files
  "description": "Clang compilation time analysis for Firefox"
}
```

---

## compilationUnits

Information about each compilation unit (object file). These are parallel arrays indexed by `compilationUnitId` (position in the arrays):

```json
{
  "names": [
    "Unified_cpp_dom_canvas1",
    "Unified_cpp_xpcom_base3",
    "Unified_cpp_dom_canvas2",
    ...
  ],
  "buildTimes": [
    12345,  // Total build time in milliseconds
    9876,
    8765,
    ...
  ]
}
```

**Sorting:**
- Arrays are sorted by **total include count descending** (most includes first)
- This means the most-referenced compilation units get smaller IDs
- Better compression in the `includes.compilationUnitIds` array

**Example lookup:**
```javascript
const compilationUnitId = 0;
const name = compilationUnits.names[compilationUnitId];  // "Unified_cpp_dom_canvas1"
const buildTime = compilationUnits.buildTimes[compilationUnitId];  // 12345 milliseconds
```

---

## tables

String tables for efficient storage. All file paths are deduplicated and stored once, sorted by frequency (most frequently included first):

```json
{
  "files": [
    // Array of header file paths, sorted by inclusion frequency (most included first)
    // Index into this array is the fileId
    "memory",
    "vector",
    "type_traits",
    "/home/user/.mozbuild/sysroot-x86_64-linux-gnu/usr/include/c++/10/bits/stl_algobase.h",
    "nsISupports.h",
    "mozilla/RefPtr.h",
    ...
  ]
}
```

**Sorting:**
- Files sorted by **total usage frequency descending**
- Most-included headers get smallest IDs for better compression
- Usage counted across all compilation units and all parent references

**Example lookup:**
```javascript
const fileId = 0;
const filePath = tables.files[fileId];  // "memory"
```

---

## includes

Contains all include relationships, organized by compilation unit. This is an **object containing arrays of arrays** (parallel arrays indexed by `compilationUnitId`):

```json
{
  "fileIds": [
    [5, 10, 15, 20, 25],           // Compilation unit 0
    [3, 8, 12, 19],                // Compilation unit 1
    [7, 14, 22],                   // Compilation unit 2
    ...
  ],
  "startTimes": [
    [3, 2, 3, 4, 3],  // CU 0 (differential, in ms)
    [3, 2, 3, 3],     // CU 1 (differential, in ms)
    [3, 3, 6],        // CU 2 (differential, in ms)
    ...
  ],
  "durations": [
    [804, 1200, 800, 350, 2000],   // CU 0
    [450, 950, 750, 1800],         // CU 1
    [300, 1100, 2200],             // CU 2
    ...
  ],
  "parentFileIds": [
    [-1, 5, 10, 10, 15],           // CU 0
    [-1, 3, 8, 8],                 // CU 1
    [-1, 7, 14],                   // CU 2
    ...
  ]
}
```

### Structure

The `includes` object contains parallel arrays where the first index is the `compilationUnitId`. To get includes for compilation unit 5:
```javascript
const cuFileIds = includes.fileIds[5];        // Array of file IDs for CU 5
const cuStartTimes = includes.startTimes[5];  // Array of timestamps for CU 5
const cuDurations = includes.durations[5];    // Array of durations for CU 5
const cuParentIds = includes.parentFileIds[5]; // Array of parent IDs for CU 5
```

Within each CU's arrays, index `i` represents one include event (parallel arrays):

### Field Descriptions

**fileIds**: Array of indices into `tables.files`
- Which header file was included
- Values range from `0` to `tables.files.length - 1`

**startTimes**: Array of **differential timestamps** in **milliseconds**
- **IMPORTANT**: These are differences, not absolute timestamps!
- First value is absolute start time
- Subsequent values are differences from the previous timestamp
- Must be decompressed to get actual timestamps (see example below)
- Example: `[3, 2, 3]` → actual times: `[3, 5, 8]` ms

**durations**: Array of durations in **milliseconds**
- How long each header took to process
- Includes time spent in nested includes
- Converted from Clang's `-ftime-trace` output (endTime - startTime) and rounded

**parentFileIds**: Array of indices into `tables.files` OR `-1`
- Which file included this header
- `-1` means included directly by the compilation unit (root of include tree)
- Otherwise contains `fileId` of the parent header

### Timestamp Decompression

The `startTimes` array uses differential compression to reduce file size. To get actual timestamps:

```javascript
function decompressTimestamps(startTimes) {
  const actual = [];
  let currentTime = 0;

  for (const diff of startTimes) {
    currentTime += diff;
    actual.push(currentTime);
  }

  return actual;
}

// Example usage
const cuId = 0;
const actualTimes = decompressTimestamps(includes.startTimes[cuId]);
// [3, 2, 3] → [3, 5, 8] (all in milliseconds)
```

### Sorting

Within each compilation unit's arrays:
- Sorted by `startTime` (chronological order)
- Already in the order includes were processed
- Timeline reconstruction is straightforward

---

## Data Relationships

### Include Tree Structure

The `parentFileIds` field creates a tree structure for each compilation unit:

```
Unified_cpp_dom_canvas1 (CU 0)
  ├─ memory (fileId=5, parentFileId=-1)           [included directly]
  │   ├─ stl_algobase.h (fileId=10, parentFileId=5)  [included by memory]
  │   │   └─ c++config.h (fileId=15, parentFileId=10) [included by stl_algobase.h]
  │   └─ type_traits (fileId=20, parentFileId=5)     [included by memory]
  └─ vector (fileId=25, parentFileId=-1)           [included directly]
```

### Leaf vs Root Includes

- **Root include**: `parentFileId = -1`
  - Included directly by the compilation unit (.cpp file)
  - Top level of the include tree

- **Nested include**: `parentFileId >= 0`
  - Included by another header file
  - Part of an include chain

- **Leaf include**: No special marker
  - Doesn't include any other files
  - Can be identified by not appearing in any other row's `parentFileIds`

---

## Usage Examples

### Example 1: Get all includes for a compilation unit

```javascript
function getIncludesForCU(cuId) {
  const result = [];

  // Decompress timestamps
  let currentTime = 0;
  for (let i = 0; i < includes.fileIds[cuId].length; i++) {
    currentTime += includes.startTimes[cuId][i];

    result.push({
      file: tables.files[includes.fileIds[cuId][i]],
      startTime: currentTime,
      duration: includes.durations[cuId][i],
      parent: includes.parentFileIds[cuId][i] === -1
        ? compilationUnits.names[cuId]
        : tables.files[includes.parentFileIds[cuId][i]]
    });
  }

  return result;  // Already sorted chronologically
}
```

### Example 2: Build include tree for visualization

```javascript
function buildIncludeTree(cuId) {
  const nodes = new Map();  // fileId -> node
  const roots = [];

  // Decompress timestamps
  let currentTime = 0;

  // First pass: create all nodes
  for (let i = 0; i < includes.fileIds[cuId].length; i++) {
    currentTime += includes.startTimes[cuId][i];
    const fileId = includes.fileIds[cuId][i];

    const node = {
      id: fileId,
      name: tables.files[fileId],
      startTime: currentTime,
      duration: includes.durations[cuId][i],
      parentFileId: includes.parentFileIds[cuId][i],
      children: []
    };

    nodes.set(fileId, node);

    if (includes.parentFileIds[cuId][i] === -1) {
      roots.push(node);
    }
  }

  // Second pass: link children to parents
  for (const node of nodes.values()) {
    if (node.parentFileId >= 0) {
      const parent = nodes.get(node.parentFileId);
      if (parent) {
        parent.children.push(node);
      }
    }
  }

  return roots;
}
```

### Example 3: Calculate rebuild impact

```javascript
function calculateRebuildImpact(headerPath) {
  const fileId = tables.files.indexOf(headerPath);
  if (fileId === -1) return { affectedCUs: [], totalTime: 0 };

  const affectedCUs = new Set();

  // Find all compilation units that include this header
  for (let cuId = 0; cuId < includes.fileIds.length; cuId++) {
    if (includes.fileIds[cuId].includes(fileId)) {
      affectedCUs.add(cuId);
    }
  }

  // Sum up their build times
  let totalRebuildTime = 0;
  for (const cuId of affectedCUs) {
    totalRebuildTime += compilationUnits.buildTimes[cuId];
  }

  return {
    affectedCUs: Array.from(affectedCUs),
    totalTime: totalRebuildTime,  // Already in milliseconds
    percentage: (totalRebuildTime / getTotalBuildTime()) * 100
  };
}

function getTotalBuildTime() {
  return compilationUnits.buildTimes.reduce((sum, t) => sum + t, 0);
}
```

### Example 4: Find most expensive headers

```javascript
function getMostExpensiveHeaders(topN = 100) {
  const headerStats = new Map();  // fileId -> {totalTime, count}

  // Aggregate all includes across all compilation units
  for (let cuId = 0; cuId < includes.fileIds.length; cuId++) {
    for (let i = 0; i < includes.fileIds[cuId].length; i++) {
      const fileId = includes.fileIds[cuId][i];
      const duration = includes.durations[cuId][i];

      if (!headerStats.has(fileId)) {
        headerStats.set(fileId, { totalTime: 0, count: 0 });
      }

      const stats = headerStats.get(fileId);
      stats.totalTime += duration;
      stats.count++;
    }
  }

  // Convert to array and sort
  const results = Array.from(headerStats.entries())
    .map(([fileId, stats]) => ({
      file: tables.files[fileId],
      totalTime: stats.totalTime,  // Already in ms
      count: stats.count,
      avgTime: stats.totalTime / stats.count  // Already in ms
    }))
    .sort((a, b) => b.totalTime - a.totalTime)
    .slice(0, topN);

  return results;
}
```

### Example 5: Calculate self-time for a header

```javascript
function calculateSelfTime(cuId, includeIndex) {
  const fileId = includes.fileIds[cuId][includeIndex];
  const totalDuration = includes.durations[cuId][includeIndex];

  // Find all direct children (where parentFileId equals this fileId)
  let childrenTime = 0;
  for (let i = 0; i < includes.fileIds[cuId].length; i++) {
    if (includes.parentFileIds[cuId][i] === fileId) {
      childrenTime += includes.durations[cuId][i];
    }
  }

  return totalDuration - childrenTime;
}
```

### Example 6: Generate timeline for profiler view

```javascript
function generateProfilerTimeline(cuId) {
  const samples = [];

  // Decompress timestamps
  let currentTime = 0;

  for (let i = 0; i < includes.fileIds[cuId].length; i++) {
    currentTime += includes.startTimes[cuId][i];

    // Build stack trace
    const stack = [];
    let currentFileId = includes.fileIds[cuId][i];
    let searchIndex = i;

    // Walk up the parent chain
    while (currentFileId !== null) {
      stack.unshift(tables.files[currentFileId]);

      const parentFileId = includes.parentFileIds[cuId][searchIndex];
      if (parentFileId === -1) break;

      // Find the parent include
      currentFileId = null;
      for (let j = 0; j < i; j++) {
        if (includes.fileIds[cuId][j] === parentFileId) {
          currentFileId = parentFileId;
          searchIndex = j;
          break;
        }
      }
    }

    samples.push({
      stack: [compilationUnits.names[cuId], ...stack],
      time: currentTime,  // Already in ms
      duration: includes.durations[cuId][i]  // Already in ms
    });
  }

  return samples;
}
```

---

## Data Compression Techniques

The format uses several techniques to minimize file size:

1. **String Tables**: All file paths stored once and referenced by index
2. **Frequency Sorting**: Most-used items get smallest indices (fewer digits in JSON)
3. **Array Indexing**: `includes` is an array indexed by compilationUnitId (eliminates ~16% overhead from repeated IDs)
4. **Differential Compression**: Timestamps stored as differences (reduces ~28% of file size)
5. **Parallel Arrays**: Data stored in parallel arrays instead of array of objects (avoids repeating key names)
6. **Integer Microseconds**: Timestamps and durations stored as integers, not floats
7. **Compilation Unit Sorting**: CUs sorted by include count for better access patterns

### Size Comparison

For the full Firefox build (~4,400 compilation units, ~1.3M includes):
- **Without optimizations**: ~100 MB
- **With string tables only**: ~70 MB
- **With array indexing**: ~58 MB (16% saved)
- **With differential compression**: ~33 MB (additional 43% saved)

Final compressed size: **~33 MB** (67% smaller than unoptimized)

---

## Time Units

All times are stored in **milliseconds**:

- **startTimes**: Milliseconds (differential, converted from Clang trace files)
- **durations**: Milliseconds (rounded from Clang trace files)
- **buildTimes**: Milliseconds (rounded max endTime for the compilation unit)

To convert to seconds: `milliseconds / 1000`

---

## Include Hierarchy Semantics

### Direct Includes (parentFileId = -1)

These are files included directly by the compilation unit's source file:

```cpp
// Unified_cpp_dom_canvas1.cpp
#include "ClientWebGLExtensions.h"  // parentFileId = -1
#include "WebGLContext.h"           // parentFileId = -1
```

### Nested Includes (parentFileId >= 0)

These are files included by other headers:

```cpp
// ClientWebGLExtensions.h
#include "ClientWebGLContext.h"  // parentFileId = fileId of ClientWebGLExtensions.h
```

### Duration Semantics

The `duration` field includes **all** time spent in that header, including:
- Parsing the header itself
- Processing all nested `#include` directives
- Parsing all headers included by this header

To get **self-time** (time spent only in this header, excluding nested includes), subtract the durations of all direct children.

---

## Performance Characteristics

### File Size

For the full Firefox build (~4,400 compilation units, ~1.3M includes):
- Uncompressed JSON: ~100-200 MB
- Gzip compressed: ~10-20 MB

### Loading Performance

The structure is optimized for:
- **Sequential access** within a compilation unit (common case)
- **Random access** by header name (via string table)
- **Aggregation** across all compilation units (rebuild impact)

### Memory Usage

When loaded in browser:
- Raw JSON parsing: ~100-200 MB
- Additional data structures for indexing: ~50-100 MB
- Total: ~150-300 MB (acceptable for modern browsers)

---

## Limitations

1. **No deduplication**: Same header included via different paths counted separately
2. **No macro expansion tracking**: Only file-level includes, not macro-expanded content
3. **No precompiled header data**: PCH inclusions not represented
4. **Header guard optimization**: Subsequent inclusions of guarded headers may have zero duration

---

## Version History

- **Version 1.0** (2025-12-13): Initial format
  - Basic structure with compilation units, files, and includes
  - Frequency-sorted tables
  - Parent relationship tracking
  - Timeline support with startTimes

---

## Future Enhancements

Potential additions in future versions:
- Differential timestamps (instead of absolute)
- Source/header file distinction
- Template instantiation tracking
- Include depth histogram
- Directory-level aggregation
